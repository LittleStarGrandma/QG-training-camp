# QG训练营图形组第二周周记：
2020年4月5日

## 生活随记

这周是学了很多东西的一周，也是收获很多的一周。

这周周一我们的项目答辩非常顺利，老师表扬了我们，希望院赛和校赛可以再接再励；同时这周每天晚上都坚持完成当天作业了，是个小小的进步。

第一周的作业交不上来，非常痛苦，但是在请教了小伙伴的学习方法后好像有了一些学习的思路。然鹅，不知道出于怎样的恐惧心理还是不太敢问师兄= =。

## 一周总结

总之效率可以再高一点，同时也意识到了和小伙伴们沟通、和师兄们请教的重要性，通过向别人学习可以获得更高效的学习方法。

以下是这周的学习内容概况：

指针的初始化

1、建议初始化所有指针并在可能的情况下等定义了对象之后再定义指针；

2、void：特殊的指针类型，可以存放任何对象的地址,指针指向的内容不可确定。常用于一般用来拿来和别的指针做比较，作为函数的输入和输出，赋值为另一个void*指针；
3、指针的指向再程序执行中可变；
4、指针指定一个地址后再存放变量；



引用：

1、引用不是对象；

2、引用必须和对象在一起；

3、引用必须初始化，所以引用前不需要测试其有效性，使用引用会使指针效率更高；

4、指向常量的引用是非法的：

eg. double& ref=100 ×；

​       const double&ref=100 √；

5、引用和指针的关系：引用对指针封装，底层仍然是指针，获取引用地址时，编译器会进行内部转换；

​      

```
 int num =188;

​       int &rel_num=num;

​        rel_num=118;

​       cout <<&num<<‘\t'<<&rel_num<<endl;


```



指针和数组：

1、数组名时连续储存空间的首地址（数组名就是数组的首地址）比如：num是数组名，也可以理解成数组的首地址，所以num的值与&num[0]的值是相同的；

```
double score[5]{1,2,3,4,5};

double *ptr_score;

ptr_score=&score[0];

//ptr_score=score;


```

2、数组名还是数组的类型(数组也是一个数据类型），比如说：double a[]=double[];

3、数组的第i+1个元素可表示为：

*第i+1个元素的地址：&num[i+1]或num+1;

*第i+1个元素的值：num[i+1]或 *（num+i+1）同样尝试 *++num(只能让指针++或——不能让数组名++——)；

4、为指向数组的指针赋值：

*int *ptr_num=num或 int *ptr——num=&num[0];

5、指针变量可以指向数组元素：

*int *ptr_num=&num[4]或int * ptr_num+4；







指针的运算：

1、指针的递增递减：++，--（地址的平移）；

2、一个类型为T的指针的移动，以sizeof（T）为移动单位；

3、指针自加自减的单位不是1，而是所指向的数据类型的单位长度；

4、指针不是整型，描述的是地址；

5、如果越界你的指针可能会乱指：若前面有其他数组内容则指向其他数组内容的值；



动态分配内存：new-delete

1、指针：再运行阶段分配未命名的内存以存储值：

编译阶段非配内存：如上；

运行阶段分配内存：用new：用法为 

int *p（栈区）= new int（堆区）；

 delete    p;                                                     

//在运行阶段分配一个未命名的内存，把右边的值赋给了左侧,然后用delete释放内存

2、再次情况下，只能通过指针来访问内存；

3、delete不要已经声明变量的内存，它只能释放new出来的数组；

4、不要创建向同一内存块的指针，有可能误删除两次；

5、使用new创建动态内存分配的数组：

```
int *intArray=new int[10]；
```

/*new运算符返回第一个元素的地址*/

6、使用delete[]释放内存：

```
delete[]intArray;
```



栈区（堆栈）（男人生孩子）：

1、由编译器自动分配释放的，一般存放函数的参数值，局部变量的值等；

2、操作方式类似**数据结构中的栈**：先进后出；

放数组名、变量名。

优点：访问很快，效率高



堆区（女人生孩子）：

1、成员自己分配和释放，程序结束时可能由厂做系统回收；

2、与数据结构中的堆栈时两回事分配方式类似链表；

分空间，放地址。

优点：什么都做，效率很低



全局区（静态区）：

全局变量和静态变量储存在一起，程序结束后由系统释放；

放全局变量和常量值



文字常量区：

常量字符串就放在这里，程序结束后由系统释放；



程序代码区：

存放函数体的二进制代码；



```
int num1 = 0;//全局化初始区
int* ptr1;   //全局未初始区
int main()
{
	//栈区
	int num2;
	//栈区
	char str[] = "little star";
	//栈区
	char* ptr2;
	//little star和\0在常量区，ptr3在栈区
	char * ptr3 ="tar";
	//全局初始化区
	static int num3 = 1024;
	//分配的内存在堆区
	ptr1 = new int[10];
	ptr2 = new char[5];
	//注意，ptr1和ptr2本身是在栈区的
```



/*用指针移动的方法访问数组*/

```
int arrays[]={ 1,9,3,4,10 };
	int* p_arrays = arrays;

	for (int i = 0; i < 5; i++)
	{
		cout << (*p_arrays+i) << endl;
	}
```

/*逆序输出：设置中间变量、镜像转置*/

	int arrays[]={ 1,9,3,4,10 };
	int* ptr_start = arrays;//指向第一个元素
	int* ptr_end = arrays + 4;//指向最后一个元素
	int temp;
	
	while (ptr_start != ptr_end)//镜像交换
	{
		temp = *ptr_start;
		*ptr_start = *ptr_end;
		*ptr_end = temp;
		ptr_start++;
		ptr_end--;
	}
	
		for (int i = 0; i < 5; i++) {
			cout << arrays[i] << endl;
		}



二维数组与指针：

1、首地址 &  a 0 0；

2、用指针创建二维数据：降维处理

```
//用指针创建二维数组
	int* p = new int[10];
	int(*p2)[3] = new int[5][3];//降维操作，其中，（*p2)看作int [5]
	p2[3][2] = 998;
```

	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 3; j++) {
			cout << p2[i][j] << ',';
		}
	
		cout << endl;
	
	}

小结：

1、指针的声明由基本类型，*，变量名组成；

2、指针的赋值，赋值运算符右侧必须是地址（不能用常量去分配）：普通变量+&；另一个指针或者变量或者数组：不需要&

3、指针的运算：是位置的移动

4、指针和数据的区别：指针不需要地址,但当指针作为值来操作的时候需要地址；



函数指针：

1、函数的地址是存储其机器语言代码的内存开始地址；

2、好处：可以在不同的时间使用不同的函数；（把函数当作参数来传递）

3、函数指针的声明：

```
//函数原型：

double sum(double,double);

//函数指针的声明

double(*ptr_sum)(double,double)
//该语句声明了一个指针ptr sum，指向一个函数

double*ptr_sum(double,double)
//该语句不是指针函数而是声明了一个函数，返回double*类型

```

插个题外话，补充一些在开头时需要用的一些声明：

#ifndef……//在其他文件中如果没有定义

#denfine……//那么在这个文件中定义

#endif……//如果定义了的话，则这样定义……（这个在下一个函数那里定义)

#ifdef//和endif必须成对使用

#undef//

/*使用函数指针的形式实现加减乘除的运用：*/

```
#include <iostream>
#include  <cmath>
#include "mycalc.h"

using namespace std;
int main()
{
	double num1, num2;
	double (*ptr_calc)(double, double);
	double jia(double, double);
	double jian(double, double);
	double cheng(double, double);
	double chu(double, double);
	char op;
	cout << "please enter two numbers:" << endl;
	cin >> num1, num2;
	cout << "please enter what you want to do:" << endl;
	cin >> (op);
	switch (op)
	{
	case"+":
		ptr_calc = jia;
		break;
	case"-":
		ptr_calc = jian;
		break;
	case"*":
		ptr_calc = cheng;
		break;
	case "/":
		ptr_calc = chu;
		break;
	}

print_result=(ptr_calc, num1, num2);

}

```

```
#include<iostream>
#include<cmath>

using namespace std;

double jia(double, double);
double jian(double, double);
double cheng(double, double);
double chu(double, double);
void print_result(double (*)(double,double),double,double);//三个变量：一个函数（指针），两个参数

void print_result(double(*ptr_calc)(double, double), double num1, double num2)
{
	double result = (*ptr_calc)(num1,num2);
	cout << "the result is:" << result << endl;
}
double jia(double num1, double num2)
{
	return num1 + num2;
}

double jian(double num1, double num2)
{
	return num1 - num2;
}//负数如何处理？

double cheng(double num1, double num2)
{
	return num1 * num2;
}

double chu(double num1, double num2)
{
	if (num2 == 0) {
		cout << "error!" << endl;
		return 0;
	}
	else {
		return num1 / num2;
	}
}
```

出现的问题：1、运算符前面和和后面的数据类型不一致

​                      2、？??

其他：auto 函数名、typedef可用于简化声明。

小结：函数指针可以简化函数的调用







内联函数：

1、与常规函数的区别在于编写方式（被调用的时候运行机制不一样）：

编译器使用函数代码替换函数调用；（空间换时间的方法，减去了进栈出栈的过程）

2、使用：在定义或者声明的时候加关键字inline；



栈内存与堆内存：

1、析构函数（和对象分手）：

对象过期的时候自动调用的特殊成员函数；

一般用来完成清理工作，配套：出生的时候使用出生函数；

析构函数的名称是在类名前加上“~”；

析构函数没有参数，只能有一个；

通知对象：数据要销毁了，

```
class student {
private:
	double* score;
public:
	student(int len)
	{
		score = new double[len];
	}
	~student()
	{
		delete score;
	}
};
```

引用参数的一些指导原则:

1、能够修改调用函数中的数据对象；

2、数据对象较大时传递引用可以提高程序运行的效率

3、函数中不需要修改传递的参数：如果数据对象很小，建议按值传递；传递数组只能使用指针，并使用const关键字（这样就没法修改数值）；较大对象则使用const指针或引用，以提高程序运行的效率；



getline函数：

使用方法：引用头文件#include<string>

```
using namespace std;
/*跟某人聊聊天
toname 聊天对象的名称
content 聊天对象的内容*/
string chatTo(const string& toName, const string& content)
//const表名这个函数只负责拼接字符串
{
	string msg = "*[" + toName + "]说" + content;
	return msg;
}

string chatFrom(const string & fromName, const string & content)
{
	string msg = "*[" + fromName + "]说" + content;
	return msg;
}

int main()
{
	cout << "请输入对方的名称：" << endl;
	string toName,content;
	getline(cin, toName);
	cout << "请输入发送给对方的消息：" << endl;
	getline(cin, content);
	string chatMsg = chatTo(toName, content);
	cout << endl << chatMsg << endl;

	return 0;
	}


```

面向对象：模拟现实的方法

1、对象：是由数据和容许的操作组成的封装体，与现实体有直接的对应关系；

2、面向对象不是某一语言的特性，而是一种编程思想；

函数模板：实际上是建立一个通用函数

1、函数定义是不指定具体的数据类型（用虚拟类型来代替）；

2、函数被调用时编译器根据实参反推数据结构——类型的参数化（可用虚拟的类型来代替）；

3、传的不是参数而是类型；

使用方法：

//模板头与函数声明/定义永远是不可分割的整体

template<typename(或者class) 类型参数1，typename 类型参数2，...>

返回值类型 函数名（形参列表）{

//在函数体中可以使用类型函数

}

```
template<typename T>void Swap(T&, T&);
	//使用模板技术实现变量交换值；
	template<typename T>//模板头
	void Swap(T & a, T & b)
	{
		T temp = a;
		a = b;
		b = T temp;
```

现在开始做作业吧！

1、elemtype：数据名；

2、然后就刷刷刷开始做作业了。

/*debug日记/*

在debug的过程中能够学到很多很多的东西，包括发现自己思维的缺陷和知识盲区。原来debug的过程就是人的学习过程，我们在这个过程中成为能够聪明一点的程序员。

## 存在问题

1、果然编程能力不在线的短板真的很痛苦…

2、有些代码还要多打一下；

3、发现编程的学习是没办法跳着来的，必须要循序渐进，踏踏实实把每个知识点弄懂；

## 下周规划

1、复习高数复习高数复习高数；

2、这周终于能够做出半个作业了……看起来进步很慢，下周争取能够把作业完整交上去。

3、学习实验课要用的软件；

4、继续c和c＋+的学习和练习。

